<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trò chơi Ô chữ: Thời kỳ quá độ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        .cell { width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; border: 1px solid #cbd5e1; font-weight: bold; text-transform: uppercase; background: white; transition: all 0.2s; cursor: pointer; font-size: 1.2rem; }
        .cell.keyword { background-color: #fef08a; border-color: #eab308; color: #854d0e; }
        .cell.correct { background-color: #86efac; border-color: #22c55e; cursor: default; }
        .cell.active { border: 2px solid #ef4444; background-color: #fff1f2; z-index: 10; }
        .cell.empty { background-color: transparent; border: none; cursor: default; }
        .cell.locked { pointer-events: none; }
        .active-question { border-left: 4px solid #ef4444; background-color: #fee2e2; }
        .question-done { opacity: 0.6; text-decoration: line-through; background-color: #f1f5f9; }
        
        /* Chống cuộn khi nhấn phím mũi tên */
        .no-scroll { overflow: hidden; }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-6xl mx-auto bg-white rounded-2xl shadow-xl overflow-hidden">
        <div class="bg-red-700 p-6 text-white text-center">
            <h1 class="text-3xl font-bold uppercase tracking-widest">Trò chơi Ô chữ</h1>
            <p class="opacity-80 mt-2">Giải các hàng ngang để tìm từ khóa ở hàng dọc</p>
        </div>

        <div class="flex flex-col lg:flex-row p-6 gap-8">
            <!-- Grid Area -->
            <div class="flex-1 flex flex-col items-center justify-center bg-slate-50 rounded-xl p-8 overflow-auto min-h-[500px]">
                <div id="crossword-grid" class="grid gap-1">
                    <!-- Grid will be generated by JS -->
                </div>
                
                <div id="result-banner" class="mt-8 hidden p-4 bg-yellow-100 border-2 border-yellow-400 rounded-lg text-center">
                    <span class="text-xl font-bold text-yellow-800 uppercase tracking-widest">CHÚC MỪNG! TỪ KHÓA LÀ: <span class="text-red-700">CỘNG SẢN</span></span>
                </div>
            </div>

            <!-- Questions Area -->
            <div class="w-full lg:w-96 flex flex-col gap-3 h-[500px] overflow-y-auto pr-2">
                <h3 class="font-bold text-lg text-slate-800 mb-2 border-b pb-2">Câu hỏi hàng ngang:</h3>
                <div id="questions-list" class="space-y-2">
                    <!-- Questions will be generated by JS -->
                </div>
                
            </div>
        </div>
    </div>

    <script>
        /**
         * KEYWORD: C O N G S A N (7 characters)
         * C -> CHINHTRI (pos 0)
         * O -> XAHOICU (pos 3)
         * N -> NENTANG (pos 0)
         * G -> TRUNGQUOC (pos 4)
         * S -> SONGSONG (pos 0)
         * A -> VOSAN (pos 3)
         * N -> DAUTRANH (pos 7)
         */
        const puzzle = [
            { q: "Từ chủ nghĩa tư bản lên chủ nghĩa xã hội phải trải qua một thời kỳ quá độ [...].", a: "CHINHTRI", keyPos: 0 }, 
            { q: "Thực chất thời kỳ quá độ là cuộc đấu tranh giữa nhân tố mới và tàn dư [...].", a: "XAHOICU", keyPos: 3 },
            { q: "Giai cấp vô sản cần thời gian để cải tạo xã hội cũ và xây dựng [...] của xã hội mới.", a: "NENTANG", keyPos: 0 },
            { q: "Một trong những quốc gia tiêu biểu đi lên CNXH bằng con đường quá độ gián tiếp.", a: "TRUNGQUOC", keyPos: 4 },
            { q: "Thời kỳ quá độ lên chủ nghĩa xã hội trên lĩnh vực tư tưởng – văn hóa tồn tại [...] tư tưởng vô sản và tư tưởng tư sản.", a: "SONGSONG", keyPos: 0 },
            { q: "Thời kỳ quá độ lên chủ nghĩa xã hội trên lĩnh vực chính trị Là thời kỳ thiết lập và củng cố chuyên chính  [...].", a: "VOSAN", keyPos: 3 },
            { q: "Thời kỳ quá độ lên chủ nghĩa xã hội trên lĩnh vực xã hội: Giữa các tầng lớp có vừa hợp tác, vừa [...] với nhau.", a: "DAUTRANH", keyPos: 6 }
        ];

        const gridEl = document.getElementById('crossword-grid');
        const questionsEl = document.getElementById('questions-list');
        const maxLen = 16; 
        const keyColumn = 8; 

        let currentRow = 0;
        let currentCol = keyColumn - puzzle[0].keyPos;
        const solvedRows = new Set();

        function init() {
            gridEl.innerHTML = '';
            questionsEl.innerHTML = '';
            gridEl.style.gridTemplateColumns = `repeat(${maxLen}, 40px)`;
            
            puzzle.forEach((item, rowIndex) => {
                // Render câu hỏi
                const qDiv = document.createElement('div');
                qDiv.className = "p-3 rounded border text-sm cursor-pointer hover:bg-slate-50 transition leading-relaxed";
                qDiv.id = `q-${rowIndex}`;
                qDiv.innerHTML = `<span class="font-bold text-red-700 mr-2">${rowIndex + 1}.</span> ${item.q}`;
                qDiv.onclick = () => { if(!solvedRows.has(rowIndex)) focusRow(rowIndex); };
                questionsEl.appendChild(qDiv);

                // Render ô chữ
                const startCol = keyColumn - item.keyPos;
                for (let col = 0; col < maxLen; col++) {
                    const cell = document.createElement('div');
                    if (col >= startCol && col < startCol + item.a.length) {
                        cell.className = `cell ${col === keyColumn ? 'keyword' : ''}`;
                        cell.id = `cell-${rowIndex}-${col}`;
                        cell.dataset.answer = item.a[col - startCol];
                        cell.dataset.row = rowIndex;
                        cell.onclick = () => {
                            if (!solvedRows.has(rowIndex)) {
                                currentRow = rowIndex;
                                currentCol = col;
                                updateFocus();
                            }
                        };
                    } else {
                        cell.className = "cell empty";
                    }
                    gridEl.appendChild(cell);
                }
            });

            window.addEventListener('keydown', handleKey);
            updateFocus();
        }

        function focusRow(index) {
            currentRow = index;
            currentCol = keyColumn - puzzle[index].keyPos;
            updateFocus();
        }

        function updateFocus() {
            document.querySelectorAll('[id^="q-"]').forEach(el => el.classList.remove('active-question'));
            const activeQ = document.getElementById(`q-${currentRow}`);
            if (activeQ) activeQ.classList.add('active-question');

            document.querySelectorAll('.cell').forEach(el => el.classList.remove('active'));
            const activeCell = document.getElementById(`cell-${currentRow}-${currentCol}`);
            if (activeCell) activeCell.classList.add('active');
        }

        function handleKey(e) {
            if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) {
                e.preventDefault();
            }

            if (solvedRows.has(currentRow)) return;

            const char = e.key.toUpperCase();
            const cell = document.getElementById(`cell-${currentRow}-${currentCol}`);

            if (char.length === 1 && /[A-Z0-9]/.test(char)) {
                if (cell) {
                    cell.innerText = char;
                    
                    const nextCol = currentCol + 1;
                    const nextCell = document.getElementById(`cell-${currentRow}-${nextCol}`);
                    
                    if (nextCell && !nextCell.classList.contains('empty')) {
                        currentCol = nextCol;
                        updateFocus();
                    } else {
                        checkRow(currentRow);
                    }
                }
            } else if (e.key === 'Backspace') {
                if (cell) {
                    cell.innerText = '';
                    const prevCol = currentCol - 1;
                    const prevCell = document.getElementById(`cell-${currentRow}-${prevCol}`);
                    if (prevCell && !prevCell.classList.contains('empty')) {
                        currentCol = prevCol;
                    }
                    updateFocus();
                }
            } else if (e.key.startsWith('Arrow')) {
                let nextR = currentRow;
                let nextC = currentCol;
                if (e.key === 'ArrowUp') nextR--;
                if (e.key === 'ArrowDown') nextR++;
                if (e.key === 'ArrowLeft') nextC--;
                if (e.key === 'ArrowRight') nextC++;
                
                const target = document.getElementById(`cell-${nextR}-${nextC}`);
                if (target && !target.classList.contains('empty')) {
                    currentRow = nextR;
                    currentCol = nextC;
                    updateFocus();
                }
            }
        }

        function checkRow(rowIndex) {
            const cells = Array.from(document.querySelectorAll(`.cell[data-row="${rowIndex}"]`));
            const isFull = cells.every(c => c.innerText.trim() !== "");
            
            if (!isFull) return;

            const isCorrect = cells.every(c => c.innerText.trim() === c.dataset.answer);

            if (isCorrect) {
                solvedRows.add(rowIndex);
                cells.forEach(cell => {
                    cell.classList.add('correct', 'locked');
                });
                document.getElementById(`q-${rowIndex}`).classList.add('question-done');
                
                setTimeout(() => {
                    findNextAvailableRow();
                }, 400);
            } else {
                cells.forEach(c => c.style.color = '#ef4444');
                setTimeout(() => {
                    cells.forEach(cell => {
                        cell.innerText = '';
                        cell.style.color = '';
                    });
                    currentCol = keyColumn - puzzle[rowIndex].keyPos;
                    updateFocus();
                }, 600);
            }
        }

        function findNextAvailableRow() {
            for (let i = 0; i < puzzle.length; i++) {
                if (!solvedRows.has(i)) {
                    focusRow(i);
                    return;
                }
            }
            checkWin();
        }

        function checkWin() {
            if (solvedRows.size === puzzle.length) {
                document.getElementById('result-banner').classList.remove('hidden');
                document.querySelectorAll('.cell.keyword').forEach((c, idx) => {
                    setTimeout(() => {
                        c.style.backgroundColor = '#ef4444';
                        c.style.color = 'white';
                        c.classList.add('animate-bounce');
                    }, idx * 100);
                });
            }
        }

        init();
    </script>
</body>
</html>